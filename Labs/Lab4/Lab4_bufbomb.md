# 小 提 示

本部分为小提示。

## 关于使用变量来提高调试效率

由于调试每个阶段炸弹时，需要用的命令高度重复，可以声明一个变量来简化操作，每次只需要改变这个变量的值+上下箭头即可方便快捷的完成调试。

如：

### <测试>

bomb=smoke

cat $bomb.txt |./hex2raw  | ./bufbomb -u <学号>



### <手写汇编+反汇编出带机器🐎的反汇编>

gcc -m64 -Og ./$bomb.s -c

objdump -d $bomb.o >$bomb.asm.bin.txt

<!--#注意进行32位bufbomb的时候要用-m32编译!-->



## 关于实验内容的提示

我做的是x64-O0的炸弹，

与原始版本的差别主要(貌似)在于fizz，不再是从栈中读取参数，而是从寄存器中。

~~我只负责提示，如果你们很想要更详细的东西，请去国内某些社区上查找。~~

### smoke

这是很简单的炸弹，只需要简单的计算栈帧+写入smoke的地址即可完成。

**注意大小端序问题。**

### fizz

对于x32-O0，涉及到的仍然是栈帧的计算。

对于x64-O0，你则需要手写汇编，然后反编译成带机器🐎的反汇编

写什么我不说了，和Bang差不多
手写汇编请注意立即数的符号不要忘打了

~~别问我为什么提醒这个事情~~

### bang

手写汇编，然后反编译成带机器🐎的反汇编

### boom

手写汇编，然后反编译成带机器🐎的反汇编

修复破坏的栈帧，你在用奇怪的东西覆盖缓冲区不是一共就破坏了三个东西🐎

是哪个不是很明显（

### nitro

手写汇编，然后反编译成带机器🐎的反汇编

这次栈帧是动态的，所以恢复栈帧需要手动计算来恢复到寄存器。

然后因为栈帧是动态的，所以5次攻击，每次的字符串起始位置都不一样，

~~但是对于每个人，这五个的值其实都是确定的，所以你其实可以直接写五个，那么下面的大部分内容其实都不用读了（~~

你需要挑一个最大的作为攻击代码位置，然后把攻击代码放在缓冲区最后段；攻击代码前面需要一个填充

你知道那种执不执行都没事的代码对吧？(滑稽)

**然后因为要输入五次，所以上面那种代码需要复制五份（或者是单独写五遍）之间要用某些用作输出结尾的字符来结束。不是EOF!!!~~（那么是啥你懂了吧~~**

我只能提示到这里了，因为不能作弊嘛（

~~国内某些社区上的解法不能完全适用于本次Lab4的部分炸弹，因此建议配合本 小 提 示 使用~~





<u>*最后祝各位巨佬早日Ac Lab4*</u>



**Ferdinand S. 更新于2019.11.20**











